{"title":"Evolvable APIs","githubRepo":"liferay/evolvable-apis.org","googleAnalytics":"UA-37033501-12","index":{"title":"Home","description":"Embrace rapid evolution without breaking consumers.","content":" 2018 MIT License Powered by WeDeploy™ ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/./","children":{"docs":{"title":"Docs","url":"/docs/introduction/index.html","layout":false,"content":" ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","customURL":true,"children":{"search":{"description":"Documentation search results.","hidden":true,"title":"Search","content":" Electric Docs Start learning how to leverage the power of Electric. ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/docs/search.html"},"introduction":{"title":"Introduction to Evolvable APIs","description":"Evolvable REST APIs are specially useful in contexts where the consumers are not written by the same development team as the server side API. Even more so, when the deployment and update of the consumers is specially challenging, as happens with native mobile applications and even more so, consumers present in IoT devices.","layout":"guide","icon":"streams","weight":1,"content":" {$page.description} What makes an API Evolvable? Long story short, an evolvable APIs is an API that has been decided to facilitate seamless evolution. This is achieved through set of characteristics, design principles and capabilities that confer the API the capability of evolving and adapting to changes without breaking any client that is already consuming it. And at the same time they allow clients to use them in a way that can discover and enhance its behaviour automatically when that evolution happens. This could sound like an chasing \"El Dorado\", like an impossible goal to reach, but in fact it is not. The web is almost 30 years old. If something has been proven key, is the capability of the Web to evolve gracefully over the years. Can we learn something from the web? Can we reuse any of its design principles for our own Web APIs? Can we prepare them to evolve as seamlessly as the Web? If we take a look at how some APIs are built today, we could think that unfortunately we can’t. It’s common in these days to be forced to update clients because a minor feature has been removed, changed or added in the server side. Any API can become more evolvable and it’s our goal to show how. But we think that, when necessary, we can bring some of those design principles and characteristics into the way we design and build Web APIs and take most of the benefits of Evolvability. Should your API be evolvable? The quick answer is \"It depends\". This is not a matter of black and white, of what is right and what is wrong. We are not trying to establish what is better in absolute terms. Whenever it comes to designing your Web API, the first question you should ask yourself is What are your -or your customer’s- needs? Don’t get this wrong, Evolvable APIs are not so difficult, but any API design decision must take into account costs and benefits To create an Evolvable API, there are some design principles, techniques and tools that you need to consider when crafting your Web APIs. For each of those you take into account, it will probably add a little extra complexity or require specific work to be added to the contract, the construction process or the service consumption instructions. Again, this is a balance game, maybe you don’t need all the features of a full Evolvable API, but still, you will probably want to benefit from one or more characteristics that they can bring to your API. Our best advice is that you read through the following sections and decide what fits and what does not apply to your case or foreseeable near future. Maybe you will discover that some solutions or techniques are a great fit for your API while others are not. That’s perfectly fine, nobody knows better than you what your API needs. If you are interested in learning more about Evolvable APIs, or how any of those features can affect or benefic your case, maybe you can go through our Use Cases sections in which we gather up some real cases in which Evolvable APIs have proved to release a serious pain for others. {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/introduction/index.md","id":"introduction","location":"/docs/introduction/","url":"/docs/introduction/","children":{"techniques":{"title":"Useful techniques to make your APIs evolvable","description":"","layout":"guide","icon":"flash","weight":2,"content":" As stated in the previous sections, there is several different facets that help to build Evolvable APIs. There are some which can be considered as techniques that can be implemented in different ways (like Hypermedia, which is a concept but can several different implementations), other are a set of guidelines, patterns or standards. We can consider it as the building blocks that make possible Evolvable APIs. Hypermedia Consumers, like mobile apps, should not hardcode the navigation from one user interface (let it be a screen, a web page or a panel) to another. It should neither specify directly the actions that the user can take in each screen. Then, how can consumers of an API face the navigation of the application through all the different unknown possibilities that hide behind the API contract? To enable this, each API response should provide a list of possible operation as either read-only links or actions. Each operation has a type (e.g., IANA link relations) that the consumer knows how to deal with (e.g., follow a link automatically, present an action to a user, etc...). APIs using hypermedia let the API provider control the available operations, which simplifies the consumer and decouples it from the server. To support a wide variety of functionality provided by an API, a consumer only needs to support one standard hypermedia format, and follow standard link types (e.g., IANA link relations). That way, Hypermedia, can be seen as the mechanism that enables the autodiscovering (or scouting) of all the different resources, and actions that the server can provide. Shared Vocabularies Use the language that everyone understands. It’s useful to speak a language that will result familiar to the developers of clients for your APIs. Using the same language means less misunderstandings, and it eases other participants to start talking to your APIhelps new participants to join the conversation with you. Using your own slang or assigning specific meanings you only know, will make more difficult to others to understand what you are saying. Any organization, group or individual has a different way to communicate depending on the context in which they are. For example: you can refer to things with an informal name when you are talking to your kids, or you can use slang when talking with your friends, or you can have specific aliases or specific names for certain concepts inside your company, even specific properties…. But when you need to communicate with the external world, let’s say you need to write an article for the press, negotiate something with someone that does not belong to your inner circle, or prepare some marketing messages, in that case, you will probably switch to a common standard way of expressing things to ensure that your partner understands the same thing you are expressing. That is: when you get out of your inner group, organization or ambient, you won’t want to use your specific words that maybe you only understand, you will use the concepts and words that you know everyone out there will assign the same meaning that you. With your API the same rule applies: Your internal model, your concrete naming, your specific attributes should be kept for your inner realm. Instead, you should expose the resources, attributes and concepts with not only a naming, also a structure, typing and possible constraint rules on its values that are of common use. That way you can leverage your API to be well used by a broad set of consumers, that will be understanding and using your contract with a common meaning. For that matter, there are some already agreed standard vocabularies (e.g, schema.org) that you can use and even extend if you need to. But the key point here is that you are using a common way to name and structure the model you expose. Of course, that will mean that you need to find a way to ‘translate’ between your internal model and the public model using that standard vocabularies. But you can use the Representor pattern to accomplish that and decouple the internal model and external contract. The main benefit of leveraging standard vocabularies is that API developers can make internal changes freely. Consumer developers therefore benefit from much more reuse across applications. Standards Part of the key to succeed in any environment is the ability to do the things in the same way that everyone does, that is sticking to the standards. And that’s what also made the Web succeed, scale and adapt to the evolution. For your API, you will find useful to use Standards whenever they are available and they address one of your needs. For example: HTTP as communication protocol (not just transport protocol), with their methods, headers, response codes and all the semantincs that are already defined in it. Have I heard anyone thinking in REST? ;) Hypermedia MIME types. Choose at least one (or more) of the defined standards to communicate the navigation and options that the client can take. There are several different ones: HAL, Siren, JSON-LD, Collection+JSON… Read of them and chose whichever best fits your needs. IANA Link Relations. If you need to add links between resources. (some Hypermedia Types are already using IANA Link Relations. Representor Pattern The representor pattern is a technique that allows you to decouple the internal model from the shared vocabulary you will expose in your contract The representor pattern means that will will add a component that will handle the resource that you want to serve as part of your API and will build a Representation of that resource adapted to what the customer needs or is allowed to receive. That means that you will convert your model to the shared vocabulary, but, also this is the component in which you could filter out specific information that one client should not see based on any security constraint or linked to an authorization process in your API. The Representor pattern can be used both in API producers and consumers. Versioning your API Contract Every API defines a contract that the API clients depend on. The contract may be composed of URLs, HTTP methods, error codes, message types, input params and much more. If the contract changes in a backwards incompatible way it is likely that consumers will break. What’s the best way to deal with that situation? The most evolvable way is by making your contract small enough and solid enough that you will never need to break backwards compatibility. This may sound too idealistic for people who are used to API contracts which very large surface areas such as a large list of resource URLs with careful documentation for what can be done with each of them, the input and output formats, error codes, etc. But by applying the recipes from this website you will find ways to reduce the size of the API contract, and then, not breaking backwards compatibility suddenly doesn’t seem so difficult. However, in some cases, it might be necessary to make backwards incompatible changes. In that case versioning is the least bad option. But there are many ways of doing versioning, what is the best way of doing it? Here are some suggestions: Don’t version upfront unless you know for sure that you will need to break backwards compatibility. Avoid versioning the whole API if only certain parts of it will have to change in a backwards incompatible way. Isolate the areas of the API that might have to be changed. Try to find a way to not make them part of the contract and use some discoverability features instead. For that areas where it’s not possible find a way to version only the bare minimum, for example through MIME type versioning. {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/introduction/techniques.md","id":"techniques","location":"/docs/introduction/techniques.html","url":"/docs/introduction/techniques.html"}},"childIds":["techniques"]},"recipes":{"title":"Recipes","description":"Making an API Evolvable is about how many different challenges are designed or implemented when we build it. Maybe you do not need to solve all of them for your case. In this section, we will provide some individual recipes on how to address each of this facets.","layout":"guide","icon":"streams","weight":1,"content":" {$page.description} The following subsections, will address specifics advices on how to design for each of the several useful features that will help your API to be more Evolvable. Or, maybe you do not need to make your API evolvable but you find that you can get the benefit of some of them. Read through the set of recipes and take their advice in them, here you have the menu: Supporting pagination Returning several resources in a single response Supporting custom (non-CRUD) actions Supporting asynchronous operations Supporting bulk operations Letting consumers control the fields returned Supporting several response formats for one resource Communicating consumers the available actions based on permissions Supporting sorting and filtering Supporting search Supporting multi-language content Making an API ready for inevitable contract changes Managing different states of the evolution of your contract at the same time. How to do versioning {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/recipes/index.md","id":"recipes","location":"/docs/recipes/","url":"/docs/recipes/","children":{"pagination":{"title":"Pagination","description":"","layout":"guide","icon":"flash","weight":2,"content":" Let’s say that you have created a service that returns the list of members (persons) of your site. Initially, you modeled the list to contain the basic information for each of those persons: GET api/members And the service returns that list, for example with the following structure: { \"members\" : [ { \"gender\": \"female\", \"name\": \"Sophia Hart\", \"birthDate\": \"1975-04-12T00:00Z\", \"email\": \"sophia.hart@example.com\", }, { \"gender\": \"male\", \"name\": \"John Doe\", \"birthDate\": \"1977-03-15T00:00Z\", \"email\": \"john.doe@email.com\", } ] } And it seems right at first, it serves it purpose. But soon new members start to register to your site, and the list starts growing, and growing until it reaches for example 1.000 users. That’s a big amount of information to retrieve at once, and, on top of that, probably your API consumer is not going to show to its user all that information at once (the user probably won’t go through a 1.000 items list in any case). At that point you decide that you need to add some pagination mechanism (you will also add want to add filtering mechanisms to your API, but you still will benefit from pagination in the case the request does not include any filtering criteria). So, let’s start with an outline of which information is important to handle the pagination: The first, of course is the list of contents (in this case, the members). That does not change Adding information on the page in which you are, the number of elements contained on the page, optionally the total number of elements (or approximation) or the total number of pages. Some links to navigate to The next page of the search (if there is one)s The previous page (if you are not returning the first one) The very first page. Optionally the very last page. So, the first change to our response design will be to wrap, or embed the list of items in an specific property which contains that list: { \"_embedded\" : { \"members\" : [ /.../ ] } } Now we can add the information of the number of elements, and how many elements we are returning as part of the current page: { \"count\" : 20, \"total\" : 1017, \"_embedded\" : { \"members\" : [ /.../ ] } } Now, the last step is adding, information to allow to navigate to the first, previous and/or next pages, depending on the page that your are returning. In order to add those links, we are going to stick to the standards, and there is one that addresses specifically how to add links: The IANA Link relations. We will group all those navigation links under the same attribute: { \"_links\": { \"self\": { \"href\": \"http://example.org/api/members?page=3\" }, \"first\": { \"href\": \"http://example.org/api/members\" }, \"prev\": { \"href\": \"http://example.org/api/members?page=2\" }, \"next\": { \"href\": \"http://example.org/api/members?page=4\" }, \"last\": { \"href\": \"http://example.org/api/members?page=51\" } }, \"count\" : 20, \"total\" : 1017, \"_embedded\" : { \"members\" : [ { \"gender\": \"female\", \"name\": \"Sophia Hart\", \"birthDate\": \"1975-04-12T00:00Z\", \"email\": \"sophia.hart@example.com\", }, { \"gender\": \"male\", \"name\": \"John Doe\", \"birthDate\": \"1977-03-15T00:00Z\", \"email\": \"john.doe@email.com\", } ] } } In this example, we have used the structure and attribute names that HAL proposes. There are some other alternatives based on Collection+JSON, Siren, or others. {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/recipes/pagination.md","id":"pagination","location":"/docs/recipes/pagination.html","url":"/docs/recipes/pagination.html"},"sparse-fieldsets":{"title":"Sparse Fieldsets","description":"","layout":"guide","icon":"flash","weight":3,"content":" Sometimes our API returns a representation for a resource which includes a lot of information that the API provider keeps on the information, but if you think on the different kind of consumers that you will serve and, more specifically, the possible constraints that they have, maybe it’s useful if your API allows them to specify a shorter list of attributes that they want to retrieve (instead of the whole representation of the resource). For example, think on an IoT device, which is interested in using just a single property (or a few information) of the resource for which is requesting a representation. If you also take into account that maybe the device is sending the request (and retrieving the response) using a connection that does not has very good bandwidth, it makes more sense to allow to send back just 1Kb of data, that corresponds to the information that the consumer really is interested in, instead of -let’s say- the 14kb of data used for the represent the resource in its full extend. Another scenario in which filtering this feature for your API could be useful is when a mobile application is retrieving a representation of a resource, but, because the space constraints of the screen in which that information will be displayed, some of the attributes will not be rendered. Here, the mobile app -your API customer in this case- will benefit of a more effective bandwidth usage if they can just inform your API which information they are interested in. So, how the API provider can allow the customer to specify the specific information that they want in the response? Let’s start from our service that returns the information for a member (a person) of our site: GET /api/member/15 And the server’s response includes the following representation of the requested person: { \"gender\": \"female\", \"alias\": \"Sophie\", \"name\": \"Sophia Hart\", \"jobTitle\" : \"Senior Executive\", \"birthDate\": \"1975-04-12T00:00Z\", \"birthPlace\" : { \"@type\": \"Place\", \"address\": { \"@type\": \"PostalAddress\", \"addressLocality\": \"Philadelphia\", \"addressRegion\": \"PA\" } }, \"email\": \"sophia.hart@example.com\", \"telephone\": \"555-984-394\" } Let’s say that the customer is just going to show the contact data for the user: the name, the job title and email and phone if they are present. We can prepare the API so that the list of requested fields can be specified in the URL of the request, using the fields param with a comma separated list of the attributes. GET /api/member/15?fields=name,jobTitle,email,telephone And the API provider will reply with a partial response like the following one: { \"name\": \"Sophia Hart\", \"jobTitle\" : \"Senior Executive\", \"email\": \"sophia.hart@example.com\", \"telephone\": \"555-984-394\" } For this feature, it’s really useful the use of Shared Vocabularies (i.e resources represented following the definition in schema.org) it will allow the client to know beforehand the list of fields that wants in the response, even without doing any initial request to examine the structure of the response. The usefulness of this feature can be even better when we add this support to collections. For example compare: GET api/members And the subsequent response with all the information: { \"members\" : [ { \"gender\": \"female\", \"alias\": \"Sophie\", \"name\": \"Sophia Hart\", \"jobTitle\" : \"Senior Executive\", \"birthDate\": \"1975-04-12T00:00Z\", \"birthPlace\" : { \"@type\": \"Place\", \"address\": { \"@type\": \"PostalAddress\", \"addressLocality\": \"Philadelphia\", \"addressRegion\": \"PA\" } }, \"email\": \"sophia.hart@example.com\", \"telephone\": \"555-984-394\" }, { \"gender\": \"male\", \"alias\": \"jdoe\", \"name\": \"John Doe\", \"jobTitle\": \"Sales Manager\", \"birthDate\": \"1977-03-15T00:00Z\", \"birthPlace\" : { \"@type\": \"Place\", \"address\": { \"@type\": \"PostalAddress\", \"addressLocality\": \"Los Angeles\", \"addressRegion\": \"LA\" } }, \"email\": \"john.doe@email.com\", \"telephone\": \"555-984-394\" } ] } With a request in which your customer is asking just for the specific information that it’s going to show or use on a table to the user: GET api/members?fields=name,jobTitle { \"members\" : [ { \"name\": \"Sophia Hart\", \"jobTitle\" : \"Senior Executive\" }, { \"name\": \"John Doe\", \"jobTitle\": \"Sales Manager\" } ] } {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/recipes/sparse-fieldsets.md","id":"sparse-fieldsets","location":"/docs/recipes/sparse-fieldsets.html","url":"/docs/recipes/sparse-fieldsets.html"}},"childIds":["pagination","sparse-fieldsets"]}},"childIds":["introduction","recipes","search"]},"updates":{"title":"Updates","description":"Check out what's new","updates":[{"version":"0.0.2","major":true,"features":[{"icon":"flash","title":"Added main information on landing page","description":"First version of the landing page with more info on the main concepts and why Evolvable APIs are needed."},{"icon":"code-file","title":"First draft of the Guidelines","description":"The Guidelines are a set of good practices and advice on what we should take into account in order to make our REST APIs evolvable."}]},{"version":"0.0.1","major":true,"features":[{"icon":"hammer","title":"Very first version of evolvable-apis.org","description":"This version is targeted to very early adopters. API Developers who believe there has to be a better way to do APIs so that they an evolve seamlessly over the years. And who want to participate and make it a reality."}]}],"content":" Beta ","srcFilePath":"src/pages/updates/index.soy","id":"updates","location":"/updates/","url":"/updates/"}},"childIds":["docs","updates"]}}